# Содержание
1. [Среди брокеров есть Contoller](#среди-брокеров-есть-contoller)
2. [Отличие между паттернами Outbox и Inbox](#отличие-между-паттернами-outbox-и-inbox-заключается-в-их-назначении-и-области-применения)
3. [Partitions (FIFO in partitions)](#partions-fifo-in-partitions)
4. [Data Storage](#data-storage)
5. [Storage Segments](#storage-segments)
6. [Removing Data](#removing-data)
7. [Replication](#replication)
8. [Leader replicas](#leader-replicas)
9. [Синхронизация Leader & Follower](#синхронизация-leader--follower)
10. [ACKS](#acks)
11. [Определение партиции](#определение-партиции)
12. [Consumer](#consumer)

# Среди брокеров есть Contoller
Он управляет различной конфигурацией кластера, например, назначает LEADER реплики партиций

# Отличие между паттернами Outbox и Inbox заключается в их назначении и области применения:

## Outbox Pattern
### **Назначение:** Обеспечение атомарной передачи данных между базой данных и системой сообщений (например, Kafka).

### Основные функции:

1. Гарантия доставки данных: Outbox обеспечивает, что изменения в базе данных и отправка сообщений в Kafka выполняются как единая транзакция. Это предотвращает ситуации, когда данные обновлены, но сообщение не было отправлено, и наоборот.

2. Атомарность: Все операции выполняются атомарно, то есть либо все изменения применяются, либо ничего не применяется.

### Как это работает:

- Изменения данных сначала сохраняются в таблицу outbox.

- Фоновый процесс или сервис периодически читает сообщения из таблицы outbox и отправляет их в Kafka.

- После успешной отправки сообщение помечается как обработанное.

## Inbox Pattern

### **Назначение:** Обеспечение идемпотентности при обработке входящих сообщений, чтобы одно и то же сообщение не обрабатывалось несколько раз.

### Основные функции:

1. Идемпотентность: Inbox обеспечивает, что каждое сообщение обрабатывается только один раз, даже если оно было получено несколько раз.

2. Предотвращение дублирования: За счет проверки наличия идентификатора сообщения в таблице inbox, можно избежать повторной обработки одного и того же сообщения.

### Как это работает:

- При получении сообщения из Kafka, его идентификатор сохраняется в таблицу inbox.

- Сообщение обрабатывается только в том случае, если его идентификатор отсутствует в таблице inbox.

- После успешной обработки идентификатор сообщения сохраняется в inbox, чтобы предотвратить повторную обработку.

### Краткое сравнение
- Outbox: Обеспечивает атомарность и надежность при отправке сообщений от базы данных в Kafka.

- Inbox: Обеспечивает идемпотентность и предотвращает дублирование при обработке входящих сообщений из Kafka.

Эти паттерны дополняют друг друга и помогают создать надежную и согласованную систему обмена сообщениями в распределенных системах.

## Partions (FIFO in partitions)

![image](https://github.com/user-attachments/assets/4d563c95-1e25-4222-8a8c-e913f99d9559)

## Data Storage

![image](https://github.com/user-attachments/assets/7e2a77a2-2b28-49b9-afa9-fa986404b4fd)

## Storage Segments

![image](https://github.com/user-attachments/assets/dbdaf1ed-64e7-444f-badd-c24d6bdde481)

## Removing Data

![image](https://github.com/user-attachments/assets/0c62e90b-c6a9-4af1-92c2-45d1bbdf5fa5)

Если сегменты не удаляются, значит в них есть какие-то события, у которых timestamp проставлен как далекое будущее

## Replication
Replication-factor = 2 => по две реплики у каждой партиции
Реплики одной партиции не могут находиться в одном брокере, иначе если отвалится такой брокер, то мы теряем всю партицию
![image](https://github.com/user-attachments/assets/d2f780a0-3d46-4655-a3d2-1165b841cceb)

## Leader replicas

![image](https://github.com/user-attachments/assets/8594d117-1cde-480e-ba56-022c4fc64ba0)

![image](https://github.com/user-attachments/assets/19addca1-3984-4675-a991-1ba73e4fde14)

## Синхронизация Leader & Follower
Назначаем ISR (in-sync replicas) реплики, обычно их количество = replicas_count - 1

### Потому что если сделать 4/4 ISR реплики и если отвалится хоть одна, тогда Producer не сможет ничего записывать вообще

И при записи сообщения в Leader оно записывается СИНХРОННО в ISR реплики

### ISR реплика - надежный кандидат на замену Leader, если он отвалится
![image](https://github.com/user-attachments/assets/e2d71dde-0a7c-429b-8b36-12e41d427697)

## ACKS
Producer ожидает подтверждение записи сообщения от брокеров
- 0 - не ждёт вовсе
- 1 - ждёт от Leader реплики
- -1(all) - ждёт от всех ISR реплик, включая Leader
![image](https://github.com/user-attachments/assets/7b632c06-2a5f-415d-ad07-07f25db63a18)

## Определение партиции
1) Явно указываем, что хотим записывать в определенную партицию
2) Round-robin - по порядку 1->2->3 и так по кругу
3) По хэшу ключа

![image](https://github.com/user-attachments/assets/348e1a4f-5ad2-4b96-9315-3518c29f05e0)

## Consumer
### В идеале consumers_count = leader_replicas_count
![image](https://github.com/user-attachments/assets/e94b85f6-2cb7-479c-9722-1915c48fbabf)
